<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Over 2.5 Classifier — STRONG / LESS STRONG</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#f6f8fb;padding:12px}
  .wrap{max-width:980px;margin:0 auto}
  .card{background:#fff;padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(20,20,40,0.06)}
  h1{margin:0 0 8px;font-size:18px}
  label{display:block;margin:8px 0 4px;font-weight:600}
  input,select,button{width:100%;padding:10px;border-radius:9px;border:1px solid #e6e9f2;box-sizing:border-box}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .muted{color:#6b7280;font-size:13px}
  .progress{margin-top:10px;font-size:13px;color:#374151}
  table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px}
  th,td{border:1px solid #eef2ff;padding:8px;text-align:left}
  th{background:#fbfdff}
  .tag-strong{background:#dcfce7;color:#166534;padding:6px 8px;border-radius:8px;font-weight:700}
  .tag-less{background:#fff7ed;color:#92400e;padding:6px 8px;border-radius:8px;font-weight:700}
  .warn{color:#b91c1c;font-weight:700}
  @media (max-width:600px){ .row{grid-template-columns:1fr} table{font-size:12px} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Over 2.5 — STRONG / LESS STRONG Analyzer</h1>
      <div class="muted">Choose date, paste API-Football key, then tap Generate. Only matches meeting at least "LESS STRONG" are shown.</div>

      <label>Provider</label>
      <select id="provider"><option value="direct">API-Football (dashboard key)</option><option value="rapidapi">RapidAPI (X-RapidAPI-Key)</option></select>

      <label>API Key</label>
      <input id="apiKey" placeholder="Paste API key (do not commit to repo)" autocomplete="off">

      <div class="row">
        <div>
          <label>Date</label>
          <input id="dateInput" type="date">
        </div>
        <div>
          <label>Earliest season to aggregate H2H</label>
          <input id="startSeason" type="number" min="2000" max="2026" value="2010">
        </div>
      </div>

      <div style="margin-top:8px">
        <label>Politeness delay between season calls (ms) — increase if you hit rate limits</label>
        <input id="delayMs" type="number" min="100" max="2000" value="300">
      </div>

      <button id="generateBtn" style="margin-top:12px">Generate & Analyse</button>
      <div class="progress" id="progress"></div>
      <div id="warn" style="margin-top:8px"></div>
      <div id="results" style="margin-top:10px"></div>
      <div class="muted" style="margin-top:12px">Notes: Aggregating seasons may be slow and uses many API calls. If results are empty or you hit limits, raise the start season (closer to present) or increase delay.</div>
    </div>
  </div>

<script>
(async function(){
  const providerEl = document.getElementById('provider');
  const apiKeyEl = document.getElementById('apiKey');
  const dateEl = document.getElementById('dateInput');
  const startSeasonEl = document.getElementById('startSeason');
  const delayMsEl = document.getElementById('delayMs');
  const generateBtn = document.getElementById('generateBtn');
  const progress = document.getElementById('progress');
  const results = document.getElementById('results');
  const warn = document.getElementById('warn');

  function todayISO(){ return new Date().toISOString().slice(0,10); }
  if(!dateEl.value) dateEl.value = todayISO();

  function setProgress(txt){ progress.textContent = txt; }
  function makeHeaders(key, provider){
    if(provider === 'rapidapi') return { "X-RapidAPI-Key": key, "X-RapidAPI-Host": "v3.football.api-sports.io" };
    return { "x-apisports-key": key };
  }

  async function apiFetch(url, headers){
    const res = await fetch(url, { headers });
    if(!res.ok){
      const txt = await res.text();
      throw new Error(`HTTP ${res.status}: ${txt}`);
    }
    return res.json();
  }

  // Aggregate H2H: headtohead + season-by-season for home team then filter opponent
  async function aggregateH2H(homeId, awayId, headers, startSeason, delayMs){
    let aggregated = [];
    try {
      const h2hUrl = `https://v3.football.api-sports.io/fixtures/headtohead?h2h=${homeId}-${awayId}`;
      const resp = await apiFetch(h2hUrl, headers);
      if(resp && Array.isArray(resp.response)) aggregated = aggregated.concat(resp.response);
    } catch(e){
      console.warn('headtohead failed', e);
    }
    const currentYear = new Date().getFullYear();
    for(let season = Number(startSeason); season <= currentYear; season++){
      setProgress(`Aggregating H2H season ${season} (collected ${aggregated.length})`);
      try {
        const url = `https://v3.football.api-sports.io/fixtures?team=${homeId}&season=${season}&limit=500`;
        const resp = await apiFetch(url, headers);
        const list = (resp && resp.response) ? resp.response : [];
        const matches = list.filter(f => {
          const h = f.teams?.home?.id, a = f.teams?.away?.id;
          return (h === homeId && a === awayId) || (h === awayId && a === homeId);
        });
        if(matches.length) aggregated = aggregated.concat(matches);
      } catch(e){
        console.warn('season fetch failed', season, e);
      }
      await new Promise(r => setTimeout(r, delayMs));
    }
    // dedupe by fixture id or date/home/away
    const map = new Map();
    for(const f of aggregated){
      const key = f.fixture?.id || `${f.fixture?.date}-${f.teams?.home?.id}-${f.teams?.away?.id}`;
      if(!map.has(key)) map.set(key, f);
    }
    return Array.from(map.values()).sort((a,b)=> new Date(a.fixture.date) - new Date(b.fixture.date));
  }

  // helpers for last3 with fallback to current season
  function takeLastCompleted(arr, n){
    if(!Array.isArray(arr)) return [];
    const completed = arr.filter(f => typeof f.goals?.home === 'number' && typeof f.goals?.away === 'number');
    return completed.slice(-n);
  }

  async function fetchLastThree(teamId, headers){
    // try last=3
    try {
      const r = await apiFetch(`https://v3.football.api-sports.io/fixtures?team=${teamId}&last=3`, headers);
      const data = r.response || [];
      if(Array.isArray(data) && data.length) return data;
    } catch(e){ console.warn('last=3 failed for', teamId, e); }

    // fallback season current year
    try {
      const season = new Date().getFullYear();
      const r2 = await apiFetch(`https://v3.football.api-sports.io/fixtures?team=${teamId}&season=${season}&limit=500`, headers);
      return takeLastCompleted(r2.response || [], 3);
    } catch(e){ console.warn('season fallback failed for', teamId, e); }

    return []; // empty -> unknown
  }

  // classification logic: requires exactly 3 H2H (most recent 3) & last3 for both teams (completed)
  function classifyOver25(h2hRecent3, last3A, last3B, teamAId, teamBId){
    // must have 3 H2H and 3 recent each
    if(!Array.isArray(h2hRecent3) || h2hRecent3.length < 3) return null;
    if(!Array.isArray(last3A) || last3A.length < 3) return null;
    if(!Array.isArray(last3B) || last3B.length < 3) return null;

    const totalGoals = f => (typeof f.goals?.home === 'number' && typeof f.goals?.away === 'number') ? (f.goals.home + f.goals.away) : null;
    const goalsFor = (f, id) => (f.teams?.home?.id === id) ? f.goals.home : f.goals.away;

    // H2H: each of last 3 must have total >=3
    for(const f of h2hRecent3.slice(-3)){
      const tg = totalGoals(f);
      if(tg === null || tg < 3) return null; // fails H2H -> not candidate
    }

    // STRONG check:
    const allA_strict = last3A.every(f => {
      const tg = totalGoals(f), gf = goalsFor(f, teamAId);
      return tg !== null && tg >= 3 && typeof gf === 'number' && gf >= 1;
    });
    const allB_strict = last3B.every(f => {
      const tg = totalGoals(f), gf = goalsFor(f, teamBId);
      return tg !== null && tg >= 3 && typeof gf === 'number' && gf >= 1;
    });
    if(allA_strict && allB_strict) return "STRONG";

    // LESS STRONG rules:
    // define small-failure per match: (total_goals == 2) OR (team scored == 0)
    function smallFailuresPerMatch(last3, id){
      // count matches (out of 3) where either cond holds
      let cnt = 0;
      for(const f of last3){
        const tg = totalGoals(f), gf = goalsFor(f, id);
        if(tg === null || typeof gf !== 'number') return 99; // treat as unknown/invalid -> disqualify
        const isLowTotal = (tg === 2);
        const isScoreless = (gf === 0);
        if(isLowTotal || isScoreless) cnt++;
      }
      return cnt;
    }

    const smallA = smallFailuresPerMatch(last3A, teamAId);
    const smallB = smallFailuresPerMatch(last3B, teamBId);

    // Less Strong: H2H passed earlier, NOT STRONG, and:
    // - neither team has more than 1 small failure
    // - at least one team has exactly 1 small failure
    if(smallA <= 1 && smallB <= 1 && (smallA === 1 || smallB === 1)) return "LESS STRONG";

    // otherwise not candidate
    return null;
  }

  generateBtn.addEventListener('click', async ()=>{
    results.innerHTML = ''; warn.innerHTML = ''; setProgress('');
    const apiKey = apiKeyEl.value.trim();
    const provider = providerEl.value;
    const date = dateEl.value || todayISO();
    const startSeason = Number(startSeasonEl.value) || 2010;
    const delayMs = Number(delayMsEl.value) || 300;

    if(!apiKey){
      warn.innerHTML = '<div class="warn">API key required (get free key from api-football.com). Do not commit the key.</div>';
      return;
    }

    const headers = makeHeaders(apiKey, provider);
    setProgress('Fetching fixtures for ' + date + ' ...');

    try {
      const fxResp = await apiFetch(`https://v3.football.api-sports.io/fixtures?date=${date}`, headers);
      const fixtures = fxResp.response || [];
      if(!fixtures.length){
        results.innerHTML = `<div class="muted">No fixtures found for ${date}.</div>`;
        setProgress('');
        return;
      }

      const candidates = []; // only STRONG or LESS STRONG

      for(let i=0; i<fixtures.length; i++){
        const f = fixtures[i];
        const home = f.teams?.home, away = f.teams?.away;
        if(!home || !away) continue;
        setProgress(`(${i+1}/${fixtures.length}) Checking ${home.name} vs ${away.name} — aggregating H2H...`);

        // aggregate H2H
        const h2hList = await aggregateH2H(home.id, away.id, headers, startSeason, delayMs);

        // take most recent 3 H2H
        const h2hRecent3 = h2hList.slice(-3);

        // get last 3 per team (completed)
        setProgress(`(${i+1}/${fixtures.length}) Fetching last3 for ${home.name} and ${away.name}...`);
        const last3Home = await fetchLastThree(home.id, headers);
        const last3Away = await fetchLastThree(away.id, headers);

        // attach ids so helpers can use them if needed
        last3Home._teamId = home.id;
        last3Away._teamId = away.id;

        // classify
        const cls = classifyOver25(h2hRecent3, last3Home, last3Away, home.id, away.id);

        if(cls){ // we only display matches that are STRONG or LESS STRONG
          candidates.push({
            fixture: `${home.name} vs ${away.name}`,
            kickoff: f.fixture?.date ? new Date(f.fixture.date).toLocaleString() : '',
            cls,
            h2hCount: h2hRecent3.length,
            h2hDates: h2hRecent3.map(x => x.fixture?.date ? (new Date(x.fixture.date).toISOString().slice(0,10)) : 'n/a').join(', '),
            last3Home: last3Home.map(m => {
              const gh = (typeof m.goals?.home === 'number') ? m.goals.home : '?';
              const ga = (typeof m.goals?.away === 'number') ? m.goals.away : '?';
              return `${gh}-${ga}`;
            }).join(', '),
            last3Away: last3Away.map(m => {
              const gh = (typeof m.goals?.home === 'number') ? m.goals.home : '?';
              const ga = (typeof m.goals?.away === 'number') ? m.goals.away : '?';
              return `${gh}-${ga}`;
            }).join(', ')
          });
        }

        await new Promise(r => setTimeout(r, delayMs));
      }

      if(candidates.length === 0){
        results.innerHTML = `<div class="muted">No matches on ${date} met STRONG or LESS STRONG Over 2.5 criteria (or data insufficient).</div>`;
        setProgress('Done — zero candidates.');
        return;
      }

      // render table of candidates
      let html = `<table><thead><tr>
        <th>Fixture</th><th>Kickoff</th><th>Classification</th><th>H2H (last3 dates)</th><th>Home last3 scores</th><th>Away last3 scores</th>
        </tr></thead><tbody>`;
      for(const c of candidates){
        html += `<tr>
          <td>${c.fixture}</td>
          <td>${c.kickoff}</td>
          <td>${c.cls === 'STRONG' ? '<span class="tag-strong">STRONG</span>' : '<span class="tag-less">LESS STRONG</span>'}</td>
          <td>${c.h2hDates} (${c.h2hCount})</td>
          <td>${c.last3Home}</td>
          <td>${c.last3Away}</td>
        </tr>`;
      }
      html += `</tbody></table>`;
      results.innerHTML = html;
      setProgress(`Done — found ${candidates.length} candidate(s) for ${date}.`);
    } catch(err){
      console.error(err);
      results.innerHTML = `<div class="warn">Error: ${err.message}</div>`;
      setProgress('');
    }
  });

})();
</script>
</body>
</html>
